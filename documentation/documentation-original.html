<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dom99</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/polyfill.css">
    <link rel="stylesheet" href="css/documentation.css">
    <link rel="icon" href="./images/visual2.jpg">
    <link rel="prefetch" href="./">
</head>
<body>
<h1>dom99</h1>

<main>
<nav>
    <a href="./" class="nav-ext">Overview</a>
    <a href="#about">About</a>
    <a href="#examples1">Examples</a>
    <a href="#howto">Documentation</a>
    <a href="#components">Components</a>
    <a href="#plugins">Plugins</a>
    <a href="#details">Details</a>
    <a href="#timeline">Time-Line</a>
</nav>

<article id="about">
<h2>About</h2>
<img alt="dom99" src="./images/visual2.jpg">

<section>
<h3>What is dom99 ?</h3>

<p>dom99 is a <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>
framework to ease the interaction between the <a href="https://en.wikipedia.org/wiki/HTML">HTML</a>
and your program. You can pre-select DOM nodes, add event listeners and synchronize UI elements and JavaScript variables, populate HTML templates with data and insert it in the document.
You can also build the HTML with custom elements.</p>
</section>

<section>
<h3>Why use dom99 ?</h3>

<p>To spend less time in the development. dom99 encourages you to link the UI and the logic declaratively. dom99 naturally promotes to put only markup in HTML, only styling in CSS, and only logic in JS, instead of mixing things up. That prevents a lot of bugs from even existing. dom99 makes no assumption about the logic code base architecture. dom99 is fast, the source file is small (about 2KB minified+ gziped), has no external dependencies and is written respecting modern ES and HTML standards. dom99 is simple by design. You can learn how to use dom99 in less than 15 minutes. There are no build steps required.</p>

<p>Also if you want to teach people JavaScript, without having to spend too much time explaining the gimmicks of the native DOM interface, dom99 is for you. It is very beginner friendly yet powerful. <a href="manychoicesforfrontend.md">Comparisons with other frameworks</a></p>
</section>

<section>
<h3>Why not use dom99 ?</h3>
<ul>
<li>No support for some old browsers</li>
<li>Fear of the unknown</li>
<li>You have already a working code base that is maintainable</li>
<li>You need a comprehensive framework that has all the tools/components/css you need out of the box.(dom99 is not batteries included)</li>
<li>No built in server side rendering mechanism</li>
</ul>
</section>

<section>
<h3>How does dom99 work ?</h3>
<p>dom99.js is a program that exposes an application programming interface for subsequent scripts. Using <code>d.activate();</code> executes directives found in the HTML. The declarative model is translated into its imperative equivalent. After that the document object model is linked to directly accessible JavaScript variables. Changing those JavaScript variables will propagate the changes to the DOM and vice versa.</p>
</section>

<section>
<h3>Download</h3>
<p><a href="https://github.com/GrosSacASac/DOM99">GitHub</a></p>
<ul>
    <li><code><a href="https://www.npmjs.com/package/dom99">npm install dom99</a></code></li>
    <li><a download="dom99Script.es5.min.js" href="https://raw.githubusercontent.com/GrosSacASac/DOM99/master/built/dom99Script.es5.min.js"
    >Production minified dom99Script.es5.min.js</a></li>
    <li>Use a <a href="https://github.com/GrosSacASac/create-dom99-app/">premade starter pack create-dom99-app</a></li>
</ul>
</section>

<section>
<h3>Browser Support</h3>
<ul>
    <li>Chrome</li>
    <li>Samsung Internet</li>
    <li>Firefox</li>
    <li>Opera</li>
    <li>Safari</li>
    <li>Edge</li>
    <li>Internet Explorer 9+* </li>
</ul>
<p>* Supports may also requires a <a href="https://github.com/babel/babel/tree/master/packages/babel-polyfill">ES2015 polyfill</a>. A copy is included for convenience. The file is named polyfill.min.js.
Support may also require transpilation. You may also want to use built/dom99.es5.min.js. Support may also require other polyfills and transpilation see examples/css/basics.css and polyfills/ and examples/</p>
</section>

<section>
<h3>License</h3>
<p>Copyright Cyril Walle 2018.</p>
<p><a href="../LICENSE.txt ">Distributed under the Boost Software License,
Version 1.0: LICENSE.txt</a></p>
</section>

<section>
<h3>Discussion</h3>

<h4>Chat</h4>

<p><a href="https://miaou.dystroy.org/2813?dom99" alt="Chat on Miaou" title="Chat on Miaou"><img src="https://miaou.dystroy.org/static/shields/room-en.svg?v=1"></a></p>

<h4>Issues reports</h4>

<p><a href="https://github.com/GrosSacASac/DOM99/issues">Issues report</a></p>

<h4>Contributing</h4>

<p>Contributions welcome. <a href="../CONTRIBUTING.md">CONTRIBUTING.md</a></p>
</section>

</article>

<article id="howto">
<h2>How to use dom99 ?</h2>
<!-- add here download, add index.html, add main.js and all the implicit steps -->
<h3>In your HTML:</h3>

<p>dom99 will browse the DOM and react if an element has one of the following attributes</p>

<ul>
    <li>data-variable :  data binding between DOM element and js variable</li>
    <li>data-list : list is a synonym for array: display a js array as a list in the DOM</li>
    <li>data-element : pre-selecting an element for later usage</li>
    <li>data-function : adds an event listener to that element</li>
    <li>data-template : (advanced) Declare a html template to build components</li>
    <li>data-inside: (advanced)  adds the chosen template inside an encapsulated context</li>
</ul>

<p>Examples:</p>

<pre><code>&lt;input data-variable="b" type="text"&gt;
&lt;nav data-element="myNav"&gt;Navigation Links&lt;/nav&gt;
&lt;button data-function="click-deleteFoto"&gt;Delete Foto&lt;/button&gt;
&lt;d-magicbutton data-inside="1"&gt;&lt;/d-magicbutton&gt;</code></pre>

<p>The general syntax is </p>

<p><code>&lt;tag data-keyword="token1-token2" &gt; bla bla &lt;/tag&gt;</code></p>

<p>If you are not using browserify or es modules you need to include this script tag in your html <strong>before</strong> other scripts that access dom99.</p>

<pre><code>&lt;script src="node_modules/dom99/js/dom99.js"&gt;&lt;/script&gt;
&lt;script src="js/yourJavascriptFile.js"&gt;&lt;/script&gt;</code></pre>

<h3>In your JavaScript:</h3>

<pre><code>
import * as d from "./node_modules/dom99/source/dom99.js";
// to start using dom99 pre selected elements use this statement
d.activate();</code></pre>

<h3>Use data-function and d.functions for event listeners</h3>
<p>Store your functions in the d.functions object</p>

<pre><code>d.functions.functionName = aFunction;</code></pre>

<p>aFunction is called when you click this button</p>

<pre><code>&lt;button data-function="click-functionName"&gt;Action&lt;/button&gt;
// "functionName" not "aFunction"</code></pre>


<h3>Use data-variable + d.variables + d.feed for data bindings</h3>
<p>To changes the text of <code>&lt;p data-variable="talkings"&gt;&lt;/p&gt;</code> and all other element that share the variable talkings</p>

<pre><code>d.feed({talkings: `Hi`});</code></pre>

<p>Use the same data-variable="talkings" on <code>&lt;input&gt;</code> elements for two way data bindings</p>

<h3>Use data-list="x-li" to display a list</h3>
<p>See examples</p>
<h3>Use data-element and d.elements for direct element manipulation</h3>
<p>To use a pre-selected element</p>

<pre><code>d.elements.bigTitle //An element reference, we can do what we want with it
d.elements.bigTitle.remove(); //for instance remove the bigTitle node</code></pre>

<p>will remove <code>&lt;h1 data-element="bigTitle"&gt;You can remove me to make space&lt;/h1&gt;</code></p>

<h3>Use data-template to declare html templates</h3>
<p>To compose html with predefined building blocks.</p>

<pre><code>&lt;template data-template="d-comment"&gt;
    &lt;p data-variable="text"&gt;&lt;/p&gt;
    &lt;time data-variable="date"&gt;&lt;/time&gt;
&lt;/template&gt;</code></pre>


<h3>Use data-inside to put html templates copies</h3>
<pre><code>&lt;d-comment data-inside="first"&gt;&lt;/d-comment&gt;
&lt;d-comment data-inside="second"&gt;&lt;/d-comment&gt;</code></pre>

<p>To edit a comment at run time do this:</p>

<pre><code>
// manually
d.feed(`first&gt;text`, `A new comment`);
d.feed(`first&gt;date`, `Today`);

// better
d.feed(`first`, {
    text: `A new comment`,
    date: `Today`
});

</code></pre>

<p>You are ready to use dom99 ! </p>

<h2>Examples</h2>

<p><a href="../examples/index.html">Complete demo</a>. Look at the source code, there are comments.</p>
<ul hidden>
<li><a href="../examples/chat.html">Chat demo</a> </li>
<li><a href="tutorial1_chat.md">Chat demo explanations</a></li>
<li><a href="../examples/todolistmultiuser/README.md">Todo List Multi User Realtime with Node.js</a> </li>
</ul>

<h2>Complete overview</h2>

<pre><code>
d.activate();</code></pre>

<p>Use activate after having stored all the event handlers in d.functions, and before using references to nodes stored in d.elements.</p>
<p>This will look the for dom99 directives in the document tree.</p>

<p>Initialize variables with HTML. <code>d.feed</code> can then be used to over-write the default html values. Next store event listener functions in <code>d.functions</code>. You can use nodes references in <code>d.elements</code>.</p>

<h3>Use HTML templates, it is healthy</h3>

<p>There are 2 ways to use HTML templates</p>

<ul><li>Static Load time template rendering with custom elements</li><li>Run time template rendering and insertion</li></ul>

<p>Both ways are <strong>complementary</strong> and use the same core ideas. To illustrate this imagine you want to have a web page with an article and comments.
When the page loads you want to display the article and already display the 2 last comments without another client-server round-trip, later when the user scrolls down or clicks a button to show more
comments we load more comments into the page with dynamic template insertion. We here define a comment as some text and a date. What we want initially is something like this</p>

<p> Look at examples/templates1.html and examples/templates2.html and examples/templates3.html for now</p>
<pre><code>&lt;html&gt;

    &lt;article&gt;
        &lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;
    &lt;/article&gt;

    &lt;!-- a comment is some text and a date --&gt;
    &lt;template data-template="d-comment"&gt;
        &lt;p data-variable="text"&gt;&lt;/p&gt;
        &lt;time data-variable="date"&gt;&lt;/time&gt;
    &lt;/template&gt;

    &lt;d-comment data-inside="comment1"&gt;&lt;/d-comment&gt;
    &lt;d-comment data-inside="comment2"&gt;&lt;/d-comment&gt;

    &lt;button data-function="click-showNextComment"&gt;Show more comments&lt;/button&gt;

&lt;/html&gt;

Note: `&lt;d-comment&gt;` is a valid custom element, `&lt;comment&gt;` is not.</code></pre>

<p>Our initial JS code looks like this</p>

<pre><code>
import * as d from "../source/dom99.js";

d.functions.showNextComment = function(event) {
    ;//todo
};

let commentsData = {
    comment1: {
        text: `I am the first to comment, well written! Bravo!`,
        date: `In the year 2016`
    },
    comment2: {
        text: `I really appreciate your work`,
        date: `just now`
    }
};

// we could also manually assign every property in a complicated for loop
d.feed(commentsData);

d.activate();</code></pre>

<p><a href="../examples/templates1.html">Try templates1.html static template injection</a> </p>

<h3>Part 2</h3>
<pre><code>
import * as d from "../source/dom99.js";

const commentPrefix = `comment`;

let currentCommentNumber = 2;

const update = function (commentKey, commentObject) {
    d.feed(commentKey, commentObject);
};

const getDataFromFakeServer = function (urlOrWhat) {
    // fetch like simulation
    return new Promise(function (resolve, reject) {
        const fakeData = {
            text: `This is a comment that could come from the server about bla bla hard coded but could come from the server`,
            date: `just now`
        };

        window.setTimeout(function () {
            resolve(fakeData);
        }, 2000);
    });
};

d.functions.showNextComment = function (event) {
    currentCommentNumber += 1;
    let key = `${commentPrefix}${currentCommentNumber}`;

    const customElementDescription = {
        tagName: `d-comment`,
        [`data-inside`]: key
    }
    const customElement = d.createElement2(customElementDescription);

    d.activate(customElement);
    d.elements.commentSection.appendChild(customElement);
    getDataFromFakeServer(`comment?id=42`).then( //get data
        function (data) {
            update(key, data);
    });
};

let commentsData = { //initial
    comment1: {
        text: `I am the first to comment, well written! Bravo!`,
        date: `In the year 2016`
    },
    comment2: {
        text: `I really appreciate your work`,
        date: `yesterday`
    }
};

d.feed(commentsData);
d.activate();

</code></pre>
<p>The HTML is the same. <a href="../examples/templates2.html">Try templates2.html static+dynamic template injection</a> </p>

<h3>Part 3</h3>
<p>He we remove a lot of manual cruft, and use an array with data-list to display the comments</p>
<h4>HTML</h4>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;dom99 DEMO templates 3&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/basics.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/dcomment.css&quot;&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;./images/visual2.jpg&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;article&gt;
    &lt;h2&gt;Article Title&lt;/h2&gt;
    &lt;p&gt;Article&lt;/p&gt;&lt;p&gt;Blalblabla I give my opinion blabla&lt;/p&gt;
&lt;/article&gt;

&lt;!-- a comment is some text and a date --&gt;
&lt;template data-template=&quot;d-comment&quot;&gt;
    &lt;article class=&quot;d-comment&quot;&gt;&lt;!-- add a container for styling purposes --&gt;
        &lt;p data-variable=&quot;text&quot;&gt;Loading text ... (fake response takes 2sec)&lt;/p&gt;
        &lt;time data-variable=&quot;date&quot;&gt;Loading date ...&lt;/time&gt;
    &lt;/article&gt;
&lt;/template&gt;

&lt;!-- data-list=&quot;VARIABLE_NAME - CUSTOM-ELEMENT_NAME&quot; --&gt;
&lt;section data-list=&quot;comments-d-comment&quot;&gt;&lt;/section&gt;
&lt;button data-function=&quot;click-showNextComment&quot; &gt;Show more comments&lt;/button&gt;



&lt;script nomodule src=&quot;../polyfill.min.js&quot;&gt;&lt;/script&gt;
&lt;script nomodule src=&quot;polyfills/remove.js&quot;&gt;&lt;/script&gt;
&lt;script nomodule src=&quot;../built/dom99.es5.min.js&quot;&gt;&lt;/script&gt;
&lt;script nomodule src=&quot;../exampleses5/templates3.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;module&quot; src=&quot;templates3.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4>JS</h4>
<pre><code>import * as d from "../../source/dom99.js";

const update = function (commentObject, position) {
    // updates the dataStore for comments commentsData
    commentsData[position] = commentObject;
    // could sort the comments with .sort(customFunction) too
    // pushes the update to the UI
    d.feed(`comments`, commentsData);
};

const fetchData = function (urlOrWhat) {
    // fetch like simulation
    return new Promise(function (resolve, reject) {
        const fakeData = {
            text: `This is a comment that could come from the server about bla bla hard coded but could come from the server`,
            date: `just now`
        };

        window.setTimeout(function () {
            resolve(fakeData);
        }, 2000);
    });
};

d.functions.showNextComment = function (event) {

    // in the meantime already display an empty comment for instant feedback

    // remember the position to be updated later
    const position = commentsData.length;
    commentsData.push(undefined);
    // undefined has no effect on all data-variable
    // so that will effectively uses the default textContent in the HTML
    d.feed(`comments`, commentsData);
    // force UI update
    fetchData(`comment?id=42`).then( function (data) {
        update(data, position);
    });

};

// comments are now stored inside an array
// you can try to convert an Object to an Array using
// Object.values(my_object);

let commentsData = [
    {
        text: `I am the first to comment, well written! Bravo!`,
        date: `In the year 2016`
    },
    {
        text: `I really appreciate your work`,
        date: `yesterday`
    }
];

d.feed(`comments`, commentsData);
d.activate();
</code></pre>
<p><a href="../examples/templates3.html">Try templates3.html</a></p>

<h3>Dynamic template injection in general</h3>

<pre><code>&lt;body&gt;
&lt;template data-template="d-tagname"&gt;
    &lt;p data-variable="text" &gt;&lt;/p&gt;
    Any HTML ...
&lt;/template&gt;
...
&lt;div data-element="target"&gt;&lt;/div&gt;
&lt;/body&gt;

// manual, see templates3.html to see how to use shortcuts
// 0 make a description
let customElementDescription = {
    [`tagName`]: `d-tagname`,
    [`data-inside`]: `key`
}
// 1 create HTML Element
let customElement = d.createElement2(customElementDescription);

// 2 link it
d.activate(customElement);

// 3 insert the Element that has a clone as a child in the DOM
d.elements[`target`].appendChild(customElement);</code></pre>
<p>I encourage you to encapsulate what changes in functions.</p>
<h4>About templates</h4>

<p>If you have a <code>&lt;template&gt;</code> in your page, it is inert and not rendered. However the template itself with a <code>data-template</code> can be used to create copies of the content of the template. These copies can be inserted in your document. The value of the attribute data-inside is called the key in this documentation. You can use d.variables d.elements and d.functions inside templates. To differentiate the multiple template clones you use the key. For instance:</p>

<pre><code>d.variables[`key&gt;text`] = `A string`;

d.elements[`key&gt;elementName`].className = `class-fun`;</code></pre>

<p>Or</p>
<pre><code>d.variables[d.contextFromArray([`key`, `text`])] = `A string`;

d.elements[d.contextFromArray([`key`, `elementName`])].className = ...</code></pre>

<p>d.functions function the other way around. You use the same event handlers for all template copies
 and handle differences with <code>d.contextFromEvent(event)</code>. Example</p>

<pre><code>&lt;!-- HTML --&gt;
&lt;template data-template="d-tagname"&gt;
    &lt;button data-function="close" &gt;CLOSE (X)&lt;/button&gt;
    &lt;button data-function="update" &gt;Update (X)&lt;/button&gt;
    &lt;p data-variable="text" &gt;Default Text&lt;/p&gt;
    &lt;div data-element="status" class="status" &gt;&lt;/div&gt;
    &lt;ul data-list="myList-li" &gt;
        &lt;li&gt;Default List Item&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div data-inside="encapsulated" &gt;
        &lt;p data-variable="text" &gt;Other Default Text&lt;/p&gt;
    &lt;/div&gt;

    Any HTML ...
&lt;/template&gt;

&lt;!-- used like --&gt;
&lt;d-tagName data-inside=&quot;myKey0&quot;&gt;&lt;/d-tagName&gt;

&lt;!-- or --&gt;
&lt;div is=&quot;d-tagName&quot; data-inside=&quot;myKey1&quot;&gt;&lt;/div&gt;

&lt;!-- or --&gt;
&lt;div data-list=&quot;listKey-d-tagName&quot;&gt;&lt;/div&gt;


// JS
d.functions.update = function (event) {
    const key = d.contextFromEvent(event);
    // you can access variables, elements, lists, subcontext with d.contextFromArray
    //  - text -
        const textKey = d.contextFromArray([key, `text`]);
        const textVariable = d.variables[textKey]; // read
        d.feed(textKey, `New Text`); // write
    // - elements -
        const statusKey = d.contextFromArray([key, `status`]);
        const statusDiv = d.variables[textKey]; // read
        statusDiv.classList.add(`updated`) // use
    // - list -
        const listKey = d.contextFromArray([key, `myList`]);
        const listVariable = d.variables[listKey]; // read
        d.feed(listKey, [
            `a`,
            `b`,
            `c`
        ]); // write with side effect
    // - encapsulated -
        // here d.contextFromArray takes a 3 item list to go 1 level deeper the tree
        const encapsulatedTextKey = d.contextFromArray([key, `encapsulated`, `text`]);
        const textVariable2 = d.variables[encapsulatedTextKey]; // read
        d.feed(encapsulatedTextKey, `New Encapsulated Text`); // write


    // this looks verbose but it works for any kind of deep html composition.
    //If you want to target a specific element or variable you can directly write
    d.variables[`key&gt;text`];
};</code></pre>

<p>If you want to remove a custom element, also use <code>d.forgetContext(baseContext);</code> to completely delete a template clone to avoid memory leaks. Read more about it in the comments of the dom99.js file. You may also consider reusing rendered template copies instead of removing them and creating new ones.</p>
</article>

<article id="examples1">
<h2>Some Examples</h2>
<p id="errors"><noscript>Enable JavaScript to view certain part of this page.</noscript></p>
<template data-template="d-htmljsresult">
    <article class="htmljsandoutput" data-element="penContainer">
        <h3 data-variable="title"></h3>
        <section>
            <h4>HTML</h4>
            <pre><code data-variable="HtmlSourceDisplay"></code></pre>
        </section>
        <section>
            <h4>JS</h4>
            <pre><code data-variable="JsSourceDisplay"></code></pre>
        </section>
        <section>
            <h4>Result</h4>
            <div data-element="ResultDisplay"></div>
        </section>
    </article>
</template>
<d-htmljsresult data-inside="Hello World"></d-htmljsresult>
<d-htmljsresult data-inside="Hello World 2"></d-htmljsresult>
<d-htmljsresult data-inside="Multiplier"></d-htmljsresult>
<d-htmljsresult data-inside="Lists"></d-htmljsresult>
<d-htmljsresult data-inside="Lists2"></d-htmljsresult>
<d-htmljsresult data-inside="Composition"></d-htmljsresult>
<!-- Note this code was written before data-list existed so it is not written pefectly-->
</article>


<article id="components">
<h2>Components</h2>
<h3>Dialogs</h3>
<p><a href="../components/yesNoDialog/readme.md">Readme (Markdown)</a></p>
<h3>ReadTextFile</h3>
<p><a href="../components/readTextFile/readme.md">Readme (Markdown)</a></p>
</article>

<article id="plugins">
<h2>Plugins</h2>
<h3>Shake</h3>
<p><a href="../plugins/shake/readme.md">Readme (Markdown)</a></p>
</article>

<article id="details">
<h2>Details</h2>
<article id="extra-tips">
<h3>Extra Tips</h3>
<p>View components in components/ folder</p>
<p>You can handle new HTML with <code>d.activate(startNode);</code>. Already processed elements won't be affected at all because the * is added to the attribute value after that.</p>

<p>Open your console, handy warnings may appear to help you if use the not minified version.</p>

<p>You can add a class to your app element container like "not-ready". Then in your css display that .not-ready with a loading animation. Once you have initialized everything you can remove the "not-ready" class name.</p>

<p>You can change the dom99 syntax. To do that follow the instructions in js/dom99ConfigurationExample.js</p>
<p>Server side rendering is compatible with dom99, but you have to glue it together yourself. A future version will make this built in with a node extension.</p>
</article>

<article id="domgood">
<h2>The Document Object Model, the good parts</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/DOM/Node.appendChild">Node.appendChild(child)</a> to insert or move an element</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore">Node.insertBefore(childNode, insertBeforeThisNode)</a> to insert or move an element</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove">Node.remove()</a> to remove an element</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList">element.classList</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList">element.classList.remove("class-name")</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList">element.classList.add("class-name")</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events">Events</a></li>
</ul>
</article>

<article id="performance">
<h2>Performance</h2>

<h3>General Tips</h3>

<p>In short: Rendering and painting the DOM is slow,
JavaScript itself is fast.
Simply changing a class name of an element can cause the browser to do heavy computation under the hood.
 For very simple programs, performance may not be an issue at all.</p>

<ul><li>Avoid Document Object Model (DOM) Access in big loops</li>
<li>Instead compute the result in your loop first, then assign the final result to the DOM</li>
<li>Avoid read/write alternations with the DOM</li>
<li>Instead chain reads, then chain writes </li>
<li>Use callbacks or Promises or equivalent for future events (example XMLHttpRequest), never block !</li>
<li>If you have more performance issues, profile first to know what is the cause</li>
<li>If you need to do heavy computation, consider using Web Workers</li>
<li><a href="http://www.html5rocks.com/en/features/performance">More tips</a></li>
<li><a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">About layout trashing</a></li></ul>

<h3>How is dom99 fast ?</h3>
<ul><li>Load time element selection and binding instead of runtime element selection and binding </li><li>The abstraction layer is small, no assumptions are made</li><li>No complexity, no dirty checking, no separate model under the hood</li></ul>
</article>

<article id="security">
<h2>Security</h2>

<h3>General tips</h3>

<ul><li>Don't Blacklist, Aggressively Whitelist</li>
    <li>Don't mix data with code</li>
    <li>Don't trust what you don't control, validate size and format instead</li>
    <li>Every software component should be so simple that it is obviously safe</li>
    <li>Avoid complexity</li>
    <li>Prevent undefined states</li>
    <li>Talk with security experts</li>
</ul>

<h3>dom99 and security</h3>

<p>dom99 itself is secure. It does nothing by itself really. It is only a framework to organize your view. <code>d.variables</code> uses textContent or value by default. </p>

<p>If you apply the general tips above you know that you have to check if the clients browser have all features you need to run your software before running it. You also validate input on the server etc, etc. There are tons of blogs about security out there.</p>

<p>If you are letting, user write HTML make sure to whitelist a finite set of safe html tags and attributes, as data-attributes could interfere.</p>
</article>
</article>


<article id="timeline">
<h2>Time-Line</h2>

<article id="patchnotes">
<h3>Patch Notes</h3>
<h4>Version 15.4.0</h4>
<p>expose d.element(string) function. It is a convenience function for d.elements[string]. It is safer to use because it cannot accidently set private variables.</p>
<h4>Version 15.3.0</h4>
<p>add options.firstVariableValueStrategy. It can be set to undefined which is the default with same behaviour as before, or set to d.FIRST_VARIABLE_FROM_HTML or d.FIRST_VARIABLE_FROM_USER_AGENT or a custom function (element) =&gt; value</p>
<h4>Version 15.2.0</h4>
<p>expose d.get(string) function. It is a convenience function for d.variables[string]. It is safer to use because it cannot accidently set private variables without explicit d.feed()</p>
<h4>Version 15.1.0</h4>
<p>Factory for creating independent dom99 realms is now provided. The main dom99.js interface remains unchanged and still exports a singleton. Internally dom99.js now imports dom99create.js, creates one instance and exports it. Have a look at source/dom99.js to know how to use this feature.</p>
<h4>Version 15.0.0</h4>
<p> The new way of importing is
    <code>import * as d from "./node_modules/dom99/built/dom99ES.js";</code>
    It is equivalent to

<pre>
<code>import {
    start,
    activate,
    elements,
    functions,
    variables,
    feed,
    forgetContext,
    deleteTemplate,
    contextFromArray,
    contextFromEvent,
    getParentContext, plugin, options, createElement2
} from "./node_modules/dom99/built/dom99ES.js";
const d = {
    start,
    activate,
    elements,
    functions,
    variables,
    feed,
    forgetContext,
    deleteTemplate,
    contextFromArray,
    contextFromEvent,
    getParentContext, plugin, options, createElement2
};</code>
</pre>
but without runtime overhead.
</p>
<p>
    Removed built/dom99.min.js
</p>
<h4>Version 14.4.0</h4>
<p>Added built/dom99ES.min.js, deprecated built/dom99.min.js</p>
<h4>Version 14.3.0</h4>
<p>Added built/dom99ES.js (single file)</p>
<h4>Version 14.2.0</h4>
<p>Added export <code>idGenerator</code></p>
<h4>Version 14.1.0</h4>
<p>Added plugin type <em>cloned</em>. It allows to target a template copy just before it is inserted into the document</p>
<h4>Version 14.0.0</h4>
<p>Added plugin system for variables:</p>
    <ul>
        <li><code>d.feed</code></li>
        <li><code>data-variable="a"</code></li>
        <li><code>data-list="list-li"</code></li>
    </ul>
<p>Refactored plugin system</p>
<h4>Version 13.0.8</h4>
<p>terser is used for minifying</p>

<h4>Version 13.0.0</h4>
<p>The library is now an ES module first. From that, <em>script require and amd</em> are built. The default export is split into 4 named exports <code>{d, plugin, options, createElement2}</code></p>

<p>Changes required in the code:</p>
<p><code><em>d.plugin --&gt; plugin</em></code></p>
<p><code><em>d.options --&gt; options</em></code></p>
<p><code><em>d.createElement2 --&gt; createElement2</em></code></p>

<p>For ES module users: <em>built/dom99Module.js --&gt; source/dom99.js</em></p>
<p>Replace <code>import d from "...built/dom99Module.js";</code> with <br><code>import {d, plugin, options, createElement2} from ".../source/dom99.js";</code></p>

<p>For script users: <em>js/dom99.js --&gt; built/dom99Script.js</em></p>
<p><em>built/dom99.es5.min.js --&gt; built/dom99Script.es5.min.js</em></p>
<p>Add <code>const {d, plugin, options, createElement2} = dom99;</code></p>

<p>For browserify users</p>
<p>Replace <code>const d = require("dom99");</code> with <br><code>const {d, plugin, options, createElement2} = require("dom99");</code></p>

<p>Added dom99Amd.js</p>
<h4>Version 12.0.0</h4>
<p>Components readTextFile and yesNoDialog now use dependency injection. Use `useReadTextFile(d);` or `useYesNoDialog(d);` before `d.start();` or similar.</p>
<h4>Version 11.1.4</h4>
<p>File built: <em>built/dom99Module.min.js</em></p>
<h4>Version 11.1.0</h4>
<p>ReadTextFile component is available</p>
<h4>Version 11.0.0</h4>
<p>Removed a IE bugfix that is already resolved by <a href="https://www.npmjs.com/package/template-mb">template-mb</a></p>
<h4>Version 10.0.0</h4>
<p><code>d.feed</code> signature is inverted to be more like JS Objects and Maps and Arrays</p>
<pre><code>
    feed = function (startPath, data) {
        if (data === undefined) {
            data = startPath;
            startPath = ``;
        }
</code></pre>
<p>With one parameter the effect is the same as before</p>
<p>With two parameters the startPath is now the first argument</p>

<pre><code>
    find:
        d\.feed\((.+)\, (.+)\)
    replace:
        d.feed($2, $1)
</code></pre>
<h4>Version 9.1.0</h4>
<p>Plugins are introduced !</p>
<p>Plugin: shake</p>
<h4>Version 9.0.0</h4>
<p>IE 9 support is now mantained by external polyfills</p>
<p>The result is that base dom99 is now even lighter</p>
<p>To still support IE 9+ <code>npm install <a href="https://www.npmjs.com/package/template-mb">template-mb</a></code> and include it like in the file <code><a href="../examples/index.html">examples/index.html</a></code></p>
<p>More updates like these are coming</p>
<p>Bower and bower.json has been dropped</p>
<h4>Version 8.2.0</h4>
<p>Support for cases when an element is inside another that uses
<code>data-function</code> Ex. button &gt; span</p>
<h4>Version 8.1.0</h4>
<p>Files are now built:</p>
<ul>
    <li>built/dom99Module.es5.js</li>
    <li>built/dom99Require.es5.js</li>
</ul>
<h4>Version 8.0.0</h4>
<p>Simplified internal code</p>
<h5>Renamed</h5>
<ul>
    <li>forgetRemoveTemplate into deleteTemplate</li>
    <li>linkJsAndDom into activate</li>

    <li>options.attributeValueDoneSign into options.doneSymbol</li>
    <li>options.elementsForUserInputList into options.tagNamesForUserInput</li>
    <li>options.directives.directiveFunction into options.directives.function</li>
    <li>options.directives.directiveVariable into options.directives.variable</li>
    <li>options.directives.directiveElement into options.directives.element</li>
    <li>options.directives.directiveInside into options.directives.inside</li>
    <li>options.directives.directiveList into options.directives.list</li>
    <li>options.directives.directiveTemplate into options.directives.template</li>
</ul>
<h5>Added</h5>
<ul>
    <li>options.propertyFromElement</li>
    <li>options.eventNameFromElement</li>
</ul>
<h5>Removed</h5>
<ul>
    <li>options.variablePropertyFromTagAndType</li>
    <li>options.eventFromTagAndType</li>
</ul>
<h4>Version 7.2.18</h4>
<p>.npmignore added. This keeps the size to a minimum for npm users</p>
<h4>Version 7.2.16</h4>
<p>Removed warnings that came from dom99</p>
<p>Possible speed ups</p>
<h4>Version 7.2.13</h4>
<p>fixed a hard to find bug, that only occurred on edge, but not IE</p>
<p>overall small improvements</p>
<h4>Version 7.2.5</h4>
<p>Polyfill for hidden</p>
<p>Better css</p>
<p>prompt equivalent now in yesNoDialog components folder</p>
<h4>Version 7.2.3</h4>
<p>Enabled IE 10 again</p>
<p>Doc hyperlink is now latest in readme</p>
<h4>Version 7.2.1</h4>
<p>Fixed non html-escaped issues in the doc</p>
<h4>Version 7.2.0</h4>
<p>data-inside extension, can now be used without is="" and without custom element. In this case all children will be encapsulated under the name space of the data-inside attribute.
Good for encapsulation of independent components. See how it is used in components/yesNoDialog/</p>
<p>YesNoDialog remake, and compatible again with the last major dom99 version</p>
<p>dom99ConfigurationExample  remake with clearer steps</p>
<p>added deleteTemplate</p>
<p>fixed a potential memory leak</p>
<h4>Version 7.1.0</h4>
<p>Upgrade the doc</p>
<p>experimenting with d.start(userFunctions = {}, initialFeed = {}, startElement = document.body, callBack = undefined)</p>
<p>d.start does what you think, the right way</p>
<pre><code>const start = function (userFunctions = {}, initialFeed = {}, startElement = document.body, callBack = undefined) {
        Object.assign(functions, userFunctions);
        feed(initialFeed);
        activate(startElement);
        if (!callBack) {
            return;
        }
        return callBack();
    };</code></pre>
<h4>Version 7.0.0</h4>
<p>renamed dom99 variable into just d</p>
<p>d.getParentContext removed. To navigate through context there are now  3 functions that work together:</p>
<ul>
    <li><code>d.contextFromEvent</code> to get the context from the event</li>
    <li><code>d.contextFromArray</code> to build up a direct access string to go 1 level up the tree</li>
    <li><code>d.getParentContext</code>  to go 1 level down the tree</li>
</ul>
<p>this model is more flexible than before but requires more code, example to change color from sister element</p>
<pre><code>&lt;button data-function="changeSister"&gt;Click Me&lt;/button&gt;
&lt;div data-element="div"&gt;Lorem Ipsul sister&lt;/div&gt;

d.functions.changeSister = function (event) {
    const thisContext = d.contextFromEvent(event);
    const sisterAccessContext = d.contextFromArray([thisContext, "div"]);
    const sisterDiv = d.elements[sisterAccessContext];
    sister.Div.classList.add("red");
};(
</code></pre>
<p>This works anywhere including, deep inside other data-list="" and data-inside=""
The div does not have to be a sister element html speaking, but only from dom99 point of view

This would work too</p>
<pre><code>&lt;button data-function="changeSister"&gt;Click Me&lt;/button&gt;
    &lt;footer&gt;
        &lt;time&gt;&lt;div data-element="div"&gt;Lorem Ipsul sister&lt;/div&gt;&lt;/time&gt;
    &lt;/footer&gt;</code></pre>
<p>To go one level down use d.getParentContext(context)</p>
<p>Now use boost license. It is more permissive than MIT because you don't need to include (but still can if you want)
the license in distributed executables or transpiled code</p>
<p>Getting data uses d.variables</p>
<p>Setting data uses           d.feed({
            result: "Please enter finite numbers"
        }); or d.feed("result", "Please enter finite numbers");
          Setting data previously called a function (object setter) but it was implicit. Now it is explicit</p>
<p>dom variables are not always converted to Strings anymore. this makes d.bool anymore</p>

<h4>Version 5.0.0</h4>
<p>Renamed <code>data-vr</code> into <code>data-variable</code></p>
<p>Split <code>data-el</code> into <code>data-element</code> and <code>data-template</code></p>
<p>Renamed <code>data-fx</code> into <code>data-function</code></p>
<p>Renamed <code>data-in</code> into <code>data-inside</code></p>
<h4>Version 4.0.0</h4>
<p>Unpublished</p>
<h4>Version 3.0.3</h4>
<p>Omitting the event type with data-function will now use default sane event types. See variable eventFromTag in dom99.js for more information</p>
<h4>Version 3.0.1</h4>
<p>Fixed a rare bug that could occur with a a property name hasOwnProperty</p>
<p>The es5 version and the source dom99.js will now do strictly the same except for logging errors and warnings. There will no longer be invisible checks at runtime to see if the arguments are valid, only logs, this should slightly improve performance</p>
<h4>Version 2.0.0</h4>
<p>Switched to SEMVER versioning</p>
<p>d.variables setter will not transform into a string anymore, D.bool is removed as it is no longer needed</p>
<p>D.followPath, removed. The event object is not extended anymore. To get the context use D.getParentContext(event.target) instead. It returns a static context object</p>
<pre><code>
{
    el,
    vr,
    baseEl
}
</code></pre>
<p>New function syntax for multiple listeners data-function="event1-function1,event2-function2"</p>
<p>d.functions must now be populated before d.activate() is called</p>
<p>
    eventFromTagAndType
        changed into eventNameFromElement
  </p>
<p>
    variablePropertyFromTagAndType
        changed into variablePropertyFromElement
  </p>
<p>
    elementsForUserInputList
        changed into tagNamesForUserInput</p>
<p>data-template="d-name" added
    data-element="template-d-name" removed</p>

<h4>Version 1.23.24</h4>
<p>dom99 components, see components/ folder for more information.</p>
<p>Removed event.dIn. Use D.followPath(d.variables, event.dKeys) or similar instead.</p>
<p>Added event.dHost for the event object for data-function. This is the host element with data-inside or document.body if there is none. It should be used instead of the old .xel hack.</p>
<p>Changed, the event object for data-function. It now exposes event.dKeys and event.dIn. event.dIn is a direct shortcut for d.variables and d.elements, that are at the same nested level as element with the function. D.xel does not exist anymore. Use data-element if you still need the custom elements reference.</p>
<p>It is now possible to use custom elements with the standard "is" attribute. Check examples/index.html and examples/main.js to see how to</p>
<p>data-function can now be used with just the function. If that happens the event is chosen with the dom99.options.eventFromTagAndType function, that you can customize.</p>
<p>You can now compose the html deeply. That means that you can now use custom elements inside custom elements. You can use data-inside in a template.</p>
<h4>Version 1.17.0</h4>
<p>Directive data-list to map an array as a list in the DOM, see examples. Removed it from data-variable because it was confusing and it didn't do the same thing at all. If you use use a list of objects you can customize exactly how the mapping is done. See second Lists example. The custom configuration has changed too.</p>
<p>Only two way data binding for input and textarea elements. Less useless eventlisteners on the page. If you want to use the contenteditable attribute(not a good idea) then add the elements tag Names to the dom99.options.elementsForUserInputList list with the push method.</p>
<h4>Version 1.15.0</h4>
<ul>
    <li>You can now use <del>data-variable="x-li"</del> on a ol for example to display the x array as multiple li elements see examples/test.html</li>
    <li>Changed the way to configure dom99</li>
    <li>You can now control what gets changed with data-variable</li>
   </ul>
<h4>Version 1.12.0</h4>
<p>function available: D.bool. When you assign a value to d.variables.x it is converted to a String. When you get a value from d.variables.x it is a string. Now with&lt;input data-variable="x" type="checkbox"&gt; you might want to get a boolean instead of "false" or "true". Use D.bool(d.variables.x)</p>
<p>input type="range" now uses the change event</p>
<h4>Version 1.10.0</h4>
<p>Less Confusion:</p>
<ul><li><code>data-scope</code> becomes <code>data-inside</code></li><li><code>D.forgetScope</code> becomes <code>D.forgetKey</code></li><li><code>event.scope</code> becomes <del><code>event.dKey</code></del></li><li><code>dom99.directives.directiveScope</code> becomes <code>dom99.directives.directiveIn</code> (if you used a custom syntax)</li></ul>
</article>

<article>
<h3>Future</h3>
<h4>Abstract directions for the future or Specification</h4>
<ul><li>Freedom</li><li>Simplicity in system and usage</li><li>Encourage declarative UI programming models</li><li>Focus on the view</li><li>Built on top of web standards</li><li>Not bloat ware</li></ul>
<p>This leaves more freedom to combine dom99 with the other needs. I encourage you to use simplified APIs for client-server communication alongside dom99 and anything else that is complementary to accelerate the development process.</p>
</article>

<article id="history">
<h3>History</h3>
<p>The first version of dom99 was rapidly prototyped by Cyril Walle (GrosSacASac) in late 2015 for JavaScript teaching purposes to people with a designer background. It was easy to let them play with their first JavaScript functions and see result on the web page just by assigning the result in a JS variable. It took away all the headaches about DOM manipulation. It was written in ES2015 code and transpiled to ES5.</p>
<p>In march 2016 I decided to share dom99 after heavy code changes on GitHub and NPM in its own repository instead of some sub-folder in some other project.</p>
<p>Late 2017, new design decisions based on new experience acquired since then. The version is a major change. For older versions, have a look at <a href="https://github.com/GrosSacASac/DOM99/tree/4616579a39a34a79cc9026d6222b2bf70f9e052b">1.23.0</a> and <a href="https://github.com/GrosSacASac/DOM99/tree/398b00576e76634eb08f5fb46113c6862509a93b">1.5.7</a>
 and <a href="https://github.com/GrosSacASac/DOM99/commit/62947dbe5076fdf4dd6cd032a971123116eeb647">4.0.0</a>.</p>
 <p>     <a href="https://rawgit.com/GrosSacASac/DOM99/master/documentation/presentation/reveal.js-2.6.2/test/examples/dom99.html#/">Presentation 2018</a>
 </p>
</article>

</article>

<script nomodule src="./deps/polyfill.min.js"></script>
<script nomodule src="./deps/remove.js"></script>
<script nomodule src="./deps/dom99Script.es5.min.js"></script>
<script type="module">
// Import
import * as d from "./deps/dom99ES.min.js";
window.d = d;
window.usesModules = true;
</script>
<!-- Usually inline scripts are bad, but here we use them to display the source of the script with .textContent as well as executing it. Without need to use extra XHRs Also not indented first for pre tags -->

<!-- Hello World -->
<template data-element="Hello WorldHtml">
<span data-variable="myVariable"></span>
</template>

<script nomodule>
Object.assign(window, dom99);
</script>

<script nomodule data-element="Hello WorldJs">
d.feed({myVariable : "Hello World"});
</script>

<!-- Hello World 2-->
<template data-element="Hello World 2Html">
<label>Input: <input data-variable="text"></label>
<p data-variable="text"></p>
</template>

<script nomodule data-element="Hello World 2Js">
d.feed({text : "Hello dom99"});
</script>

<!-- Multiplier-->
<template data-element="MultiplierHtml">
<label>a<input data-variable="a" data-function="calculate" type="range" min="-1" max="12" step="1"></label>
<span>X</span>
<label>b: <input data-variable="b" data-function="calculate" type="range" min="-1" max="12" step="1"></label>

<span data-variable="a"></span>
<span>X</span>
<span data-variable="b"></span>
<span>=</span>
<output data-variable="result"></output>
</template>

<script nomodule data-element="MultiplierJs">

d.functions.calculate = function (event) {
    d.feed({
        result: String(Number(d.variables.a) * Number(d.variables.b))
    });
};

d.feed({
    a: "7",
    b: "6"
});
//invoke event handler to compute the first result
d.functions.calculate();
</script>


<!-- Lists -->
<template data-element="ListsHtml">
<ul data-list="fruits-li"></ul>
</template>

<script nomodule data-element="ListsJs">
d.feed("fruits", ["apple", "kiwi", "banana", "orange"]);
</script>

<!-- Lists2 -->
<template data-element="Lists2Html">
<img data-variable="image" alt="">
<select data-variable="image" data-list="images-option" name="image"></select>
<p>You selected <span data-variable="image"></span></p>
</template>

<script nomodule data-element="Lists2Js">
d.feed("images", [
    {
        textContent: "you",
        value: "./images/you.jpg"
    },
    {
        textContent: "boss",
        value: "./images/boss.jpg"
    },
    {
        textContent: "sister",
        value: "./images/sister.jpg"
    }
]);

d.feed("image", d.variables.images[0].value);
</script>

<!-- Composition -->
<!-- Template inside template causes problems in IE -->
<template data-template="user-element">
    <div class="user">
        <img data-variable="picture" alt="user-picture" class="user-picture">
        <p data-variable="bio" class="user-bio">SHORT BIO</p>
        <button class="user-contact">Contact</button>
    </div>
</template>
<template data-element="CompositionHtml">
    <!-- Define the template for an user
    every user has a picture, a short biography, and a contact button -->

    <!-- <template data-template="user-element">
        <div class="user">
            <img data-variable="picture" alt="user-picture" class="user-picture">
            <p data-variable="bio" class="user-bio">SHORT BIO</p>
            <button class="user-contact">Contact</button>
        </div>
    </template> -->

    <!-- This div is the container for each user.
    The list variable name is "users" and the template used is "user-element"
    native html elements can also be used to display a list -->

    <div data-list="users-user-element"></div>

</template>
<script nomodule data-element="CompositionJs">
d.feed({users :
    [
        {
            picture: "./images/boss.jpg",
            bio: "Loves biking and skating"
        },
        {
            picture: "./images/sister.jpg",
            bio: "Drinks tons of caf√©."
        }
]});
</script>
<!-- needs to run after all templates -->
<script nomodule src="../polyfills/built/template.js"></script>
<script nomodule src="../polyfills/template-mb-bootstrap.js"></script>
<script nomodule src="js/documentation.es5.min.js"></script>
<script type="module" src="js/documentation.js"></script>
</main>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>DOM99</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/documentation.css">
    <link rel="icon" href="../images/visual48.png">
</head>
<body>
    <h1 id="main-title">DOM99</h1>
<div class="tab-holder">

<nav>
    <a href="#about">About</a>
    <a href="#howto">How To</a>
    <a href="#examples1">Examples</a>
    <a href="#domgood">DOM</a>
    <a href="#more">Details</a>
    <a href="#discussion">Discussion</a>
    <a href="#license">License</a>
    <a href="#performance">Performance</a>
    <a href="#security">Security</a>
    <a href="#history">History</a>
    <a href="#patchnotes">Updates</a>
    <a href="#future">Future</a>
</nav>    

<article id="about">
<h2>About DOM99</h2>
<img alt="DOM99" src="../images/visual.png">

<h2>What is DOM99 ?</h2>

<p>DOM99 is a <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> framework to ease the interaction between the <a href="https://en.wikipedia.org/wiki/HTML">HTML</a> and your program. You can preselect DOM nodes, add event listeners and synchronize UI elements and JavaScript variables, populate HTML templates with data and insert it in the document. You can also build the HTML with custom elements.<a href="http://jsbin.com/kepohibavo/1/edit?html,js,output">Try the intro playground</a></p>

<h2>Why use DOM99 ?</h2>

<p>To spend less time in the developpement. DOM99 encourages you to link the UI and the logic declaratively. DOM99 naturally promotes to put only markup in HTML, only styling in CSS, and only logic in JS, instead of mixing things up. That prevents alot of bugs from even existing. DOM99 makes no assumption about the logic code base architecture. DOM99 is fast, the source file is small (about 4KB minified), has no external dependency and is written respecting modern ES and HTML standards. DOM99 is simple by design. You can learn how to use DOM99 in less than 15 minutes.</p>

<p>Also if you want to teach people JavaScript, without having to spend too much time explaining the gimmicks of the native DOM interface, DOM99 is for you. It is very beginner friendly yet powerful. <a href="manychoicesforfrontend.md">Comparisons with other frameworks</a></p>

<h2>Why not use DOM99 ?</h2>

<ul><li>No support for some old browsers</li><li>New Framework</li><li>Fear of the unknown</li><li>You have already a working codebase that is mantainable</li></ul>

<h2>How does DOM99 work ?</h2>

<p>dom99.js is a program that exposes an application programming interface for subsequent scripts. Using <code>dom99.linkJsAndDom();</code> executes directives found in the HTML. The declarative model is translated into its imperative equivalent. After that the document object model is linked to directly accessible JavaScript variables. Changing those JavaScript variables will propagate the changes to the DOM and vice versa.</p>

<h2>Downloads:</h2>


<ul><li><a href="https://raw.githubusercontent.com/GrosSacASac/DOM99/master/js/dom99.js">Development ESnext with debug messages (in the console) dom99.js</a></li><li><a href="https://raw.githubusercontent.com/GrosSacASac/DOM99/master/js/dom99.es5.min.js">Production transpiled ES5, minified dom99.es5.min.js</a></li><li><code>npm install dom99</code></li><li><code>bower install dom99</code></li></ul>

<h2>Browser Support</h2>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
<li>Opera</li>
<li>Safari*</li>
<li>Internet Explorer 10+*</li>
<p>*supports also requires a <a href="https://github.com/babel/babel/tree/master/packages/babel-polyfill">ES2015 polyfill</a>. A copy is included for convenience. The file is named polyfill.min.js</p>
</article>

<article id="patchnotes">
<h2>Notes about new versions</h2>
<h3>Breaking Changes from 1.12.x to 1.15+.x</h3>
<p>1.15.1 <li>You can now use data-vr="x-li" on a ol for example to display the x array as multiple li elements see examples/test.html</li><li>Changed the way to configure DOM99</li><li>You can now control what gets changed with data-vr</li></p>
<p>1.12.0 new function available: D.bool. When you assign a value to D.vr.x it is converted to a String. When you get a value from D.vr.x it is a string. Now with&lt;input data-vr="x" type="checkbox"&gt; you might want to get a boolean instead of "false" or "true". Use D.bool(D.vr.x)</p>
<p>1.11.0 input type="range" now uses the change event</p>
<p>In 1.10.3 data-vr optimization</p>
<p>In 1.10.2 data-fx with 1 event and 1 function only, is faster. This is usefull for events that happen alot like mousemove</p>
<h3>Breaking Changes from 1.9.x to 1.10+.x</h3>

<p>Less Confusion:</p>

<ul><li><code>data-scope</code> becomes <code>data-in</code></li><li><code>D.forgetScope</code> becomes <code>D.forgetKey</code></li><li><code>event.scope</code> becomes <code>event.dKey</code></li><li><code>dom99.directives.directiveScope</code> becomes <code>dom99.directives.directiveIn</code> (if you used a custom syntax)</li><li><code>data-scope=&quot;scopeName&quot;</code> becomes <code>data-in=&quot;Key&quot;</code> (in the documentation)</li></ul>
</article>

<article id="howto">
<h2>How to use DOM99 ?</h2>
        
<h3>In your HTML:</h3>

<p>DOM99 will browse the DOM and react if an element has one of the following attributes</p>

<ul><li>data-vr : <strong>vr for variable</strong>: data binding between DOM element and js variable</li><li>data-el : <strong>el for element</strong>: pre-selecting an element for later usage</li><li>data-fx : <strong>fx for function</strong> adds an event listener to that element</li><li>data-in: (advanced) <strong>in for in the object with this key</strong> adds the linked template copy at load time</li></ul>

<p>Examples:</p>

<pre><code>&lt;input data-vr=&quot;b&quot; type=&quot;text&quot;&gt;
&lt;nav data-el=&quot;myNav&quot;&gt;Navigation Links&lt;/nav&gt;
&lt;button data-fx=&quot;click-deleteFoto&quot;&gt;Delete Foto&lt;/button&gt;
&lt;d-magicbutton data-in=&quot;1&quot;&gt;&lt;/d-magicbutton&gt;      </code></pre>

<p>The general syntax is </p>

<p><code>&lt;tag data-keyword=&quot;token1-token2&quot; &gt; bla bla &lt;/tag&gt;</code></p>

<p>If you are not using browserify you need to include this script tag in your html <strong>before</strong> other scripts that access dom99.</p>

<pre><code>&lt;script src=&quot;js/dom99.js&quot;&gt;&lt;/script&gt;&lt;!-- or 
&lt;script src=&quot;node_modules/dom99/js/dom99.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- or 
&lt;script src=&quot;bower_components/dom99/js/dom99.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;script src=&quot;js/yourJavascriptFile.js&quot;&gt;&lt;/script&gt;</code></pre>

<h3>In your JavaScript:</h3>

<pre><code>//Use a shorter name
const D = dom99;
//to start using dom99 use this statement
D.linkJsAndDom();</code></pre>

<h3>Use data-fx and D.fx for event listeners</h3>
<p>Store your functions in the D.fx object</p>

<pre><code>D.fx.functionName = aFunction;</code></pre>

<p>aFunction is called when you click this button</p>

<pre><code>&lt;button data-fx=&quot;click-functionName&quot;&gt;Action&lt;/button&gt;
//Note we wrote functionName not aFunction</code></pre>


<h3>Use data-vr and D.vr for live variables</h3>
<p>To changes the text of <code>&lt;p data-vr=&quot;talkings&quot;&gt;&lt;/p&gt;</code> and all other element that share the variable talkings</p>

<pre><code>D.vr.talkings = &quot;Hi&quot;;</code></pre>

<p>Use the same data-vr=&quot;talkings&quot; on <code>&lt;input&gt;</code> elements for two way data bindings</p>

<h3>Use data-el and D.el for direct element manipulation</h3>
<p>To use a preselected element</p>

<pre><code>D.el.bigTitle //An element reference, we can do what we want with it
D.el.bigTitle.remove(); //for instance remove the bigTitle node</code></pre>

<p>will remove <code>&lt;h1 data-el=&quot;bigTitle&quot;&gt;You can remove me to make space&lt;/h1&gt;</code></p>

<h3>Use data-el to declare html templates</h3>
<p>To compose html with predefined building blocks.</p>

<pre><code>&lt;template data-el=&quot;commentTemplate-d-comment&quot;&gt;
    &lt;p data-vr=&quot;text&quot;&gt;&lt;/p&gt;
    &lt;datetime data-vr=&quot;date&quot;&gt;&lt;/datetime&gt;
&lt;/template&gt;</code></pre>


<h3>Use data-in to put html templates copies</h3>
<pre><code>&lt;d-comment data-in=&quot;first&quot;&gt;&lt;/d-comment&gt;
&lt;d-comment data-in=&quot;second&quot;&gt;&lt;/d-comment&gt;</code></pre>

<p>To edit a comment at run time do this:</p>

<pre><code>D.vr[&quot;first&quot;].text = &quot;A new comment&quot;;
D.vr[&quot;first&quot;].date = &quot;Today&quot;;

//or (recommended)
D.vr = { 
    first: {
        text: &quot;A new comment&quot;,
        date: &quot;Today&quot;
    }
};</code></pre>

<p>You are ready to use DOM99 ! </p>

<h2>Examples</h2>

<p>Examples use the transpiled dom99 file.</p>

<ul>
<li><a href="../examples/index.html">Basic demo</a></li>
<li><a href="../examples/chat.html">Chat demo</a> </li>
<li><a href="tutorial1_chat.md">Chat demo explanations</a></li>
<li><a href="../examples/todolistmultiuser/README.md">Todo List Multi User Realtime with Node.js</a> </li></ul>

<h2>Complete overview</h2>

<h3>Start with</h3>

<pre><code>const D = dom99;
// creates an alias
D.linkJsAndDom();</code></pre>

<p>This will look the for DOM99 directives in the document tree.</p>

<p>Initialize variables with <code>D.vr.yourtarget = ...;</code>. Next store event listener functions in <code>D.fx</code>. You can use nodes references in <code>D.el</code>.</p>

<h3>Use HTML templates, it is healthy</h3>

<p>There are 2 ways to use HTML templates</p>

<ul><li>Static Load time template rendering with custom elements</li><li>Run time template rendering and insertion</li></ul>

<p>Both ways are <strong>complementary</strong> and use the same core ideas. To illustrate this imagine you want to have a web page with an article and comments. When the page loads you want to display the article and already display the 2 last comments without another client-server round-trip, later when the user scrolls down or clicks a button to show more comments we load more comments into the page with dynamic template insertion. We here define a comment as some text and a date. What we want initially is something like this</p>

<pre><code>&lt;html&gt;

    &lt;article&gt;
        &lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;
    &lt;/article&gt;

    &lt;!-- a comment is some text and a date --&gt;
    &lt;template data-el=&quot;commentTemplate-d-comment&quot;&gt;
        &lt;p data-vr=&quot;text&quot;&gt;&lt;/p&gt;
        &lt;datetime data-vr=&quot;date&quot;&gt;&lt;/datetime&gt;
    &lt;/template&gt;

    &lt;d-comment data-in=&quot;comment1&quot;&gt;&lt;/d-comment&gt;
    &lt;d-comment data-in=&quot;comment2&quot;&gt;&lt;/d-comment&gt;

    &lt;button data-fx=&quot;click-showNextComment&quot;&gt;Show more comments&lt;/button&gt;

&lt;/html&gt;

Note: `&lt;d-comment&gt;` is a valid custom element, `&lt;comment&gt;` is not.</code></pre>

<p>Our initial JS code looks like this</p>

<pre><code>&quot;use strict&quot;;
const D = dom99;

D.fx.showNextComment = function(event) {
    ;//todo
};

let commentsData = {
    comment1: {
        text: &quot;I am the first to comment, well written! Bravo!&quot;,
        date: &quot;In the year 2016&quot;
    },
    comment2: {
        text: &quot;I really appreciate your work&quot;,
        date: &quot;just now&quot; 
    }
};

// we could also manually assign every property in a complicated for loop
D.vr = commentsData;

D.linkJsAndDom();</code></pre>

<p><a href="../examples/templates1.html">Try templates1.html static template injection</a> </p>

<h3>Part 2</h3>
<pre><code>
"use strict";
const D = dom99,
    commentPrefix = "comment";

let currentCommentNumber = 2;

const update = function(commentKey,commentObject) {
    Object.assign(D.vr[commentKey], commentObject);
};

const getDataFromFakeServer = function(commentKey) {
    const fakeData = {
        text: "This is a comment that could come from the server about bla bla hard coded but could come from the server",
        date: "just now"
    };
    window.setTimeout(function () {
        update(commentKey, fakeData);
    }, 2000);
};

D.fx.showNextComment = function(event) {
    let key,
        customElementDescription,
        customElement;
    currentCommentNumber += 1;
    key = commentPrefix + String(currentCommentNumber);
    getDataFromFakeServer(key);//get data
    customElementDescription = {
        "tagName": "d-comment",
        "data-in": key
    }
    customElement = D.createElement2(customElementDescription);
    D.linkJsAndDom(customElement);
    D.el.commentSection.appendChild(customElement);
};

let commentsData = { //intial
    comment1: {
        text: "I am the first to comment, well written! Bravo!",
        date: "In the year 2016"
    },
    comment2: {
        text: "I really appreciate your work",
        date: "yesterday" 
    }
};
D.vr = commentsData;
D.linkJsAndDom();</pre></code>
<p>The HTML is the same. <a href="../examples/templates2.html">Try templates2.html static+dynamic template injection</a> </p>
<h4>Dynamic template injection in general</h4>

<pre><code>&lt;body&gt;
&lt;template data-el=&quot;templateName-d-tagname&quot;&gt;
    &lt;p data-vr=&quot;text&quot; &gt;&lt;/p&gt;
    Any HTML ...
&lt;/template&gt;
...
&lt;div data-el=&quot;target&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

// 0 make a description
let customElementDescription = {
    &quot;tagName&quot;: &quot;d-tagname&quot;,
    &quot;data-in&quot;: &quot;key&quot;
}
// 1 create HTML ELement
let customElement = D.createElement2(customElementDescription);

// 2 link it
D.linkJsAndDom(customElement);

// 3 insert the Element that has a clone as a child in the DOM
D.el[&quot;target&quot;].appendChild(customElement);</code></pre>
<p>I encourage you to encapsulate what changes in functions.</p>
<h4>The details</h4>

<p>If you have a <code>&lt;template&gt;</code> in your page, it is inert and not rendered. However the template itself with a <code>data-el</code> can be used to create copies of the content of the template. These copies can be inserted in your document. The value of the attribute data-in is called the key in this documentation. You can use D.vr D.el and D.fx inside templates. To differentiate the multiple template clones you use the key. For instance:</p>

<pre><code>D.vr[&quot;key&quot;][&quot;text&quot;] = &quot;A string&quot;

D.el[&quot;key&quot;][&quot;myElementIWantToChangeClassNameForInstance&quot;].className = ...</code></pre>

<p>D.fx function the other way around. You use the same event handlers for all template copies and handle differences with the <code>event.dKey</code>. Example</p>

<pre><code>&lt;!-- HTML --&gt;
&lt;template data-el=&quot;templateName-d-tagname&quot;&gt;
    &lt;button data-fx=&quot;close&quot; &gt;CLOSE (X)&lt;/button&gt;
    Any HTML ...
&lt;/template&gt;

// JS
D.fx.close = function (event) {
    var key = event.dKey;
    D.xel[key].remove(); // remove the custom element from the DOM
    D.forgetKey(key); // if you never use it again
    // ...
};</code></pre>

<p>If you want to remove a custom element, also use <code>D.forgetKey(&quot;key&quot;);</code> to completly delete a template clone to avoid memory leaks. Read more about it in the comments of the dom99.js file. You may also consider reusing rendered template copies instead of removing them and creating new ones.</p>
</article>

<article id="examples1">
<h2>Some Examples</h2>
<p id="errors"><noscript>Enable JavaScript to view certain part of this page.</noscript></p>
<template data-el="htmlJsAndResultTemplate-d-htmljsresult">
    <article class="htmljsandoutput">
        <h3 data-vr="title"></h3>
        <section>
            <h4>HTML</h4>
            <pre><code data-vr="HtmlSourceDisplay"></code></pre>
        </section>
        <section>
            <h4>JS</h4>
            <pre><code data-vr="JsSourceDisplay"></code></pre>
        </section>
        <section>
            <h4>Result</h4>
            <div data-el="ResultDisplay"></div>
        </section>
    </article>
</template>
<d-htmljsresult data-in="Hello World"></d-htmljsresult>
<d-htmljsresult data-in="Hello World 2"></d-htmljsresult>
<d-htmljsresult data-in="Multiplier"></d-htmljsresult>
<d-htmljsresult data-in="Lists"></d-htmljsresult>
</article>

<article id="domgood">
<h2>The Document Object Model, the good parts</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/DOM/Node.appendChild">Node.appendChild</a> to insert or move an element</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove">Node.remove</a> to remove an element</li>
<li>element.className</li>
<li>element.classList</li>
</ul>
</article>

<article id="more">
<h3>Additional information</h3>

<p>Play around with the examples, see what they do and look at the source.</p>

<p>You can handle new HTML with <code>D.linkJsAndDom(startNode);</code>. Already processed elements won&#39;t be affected at all because the â˜€ is added to the attribute value after that.</p>

<p>Open your console, handy warnings may appear to help you if use the not minified version.</p>

<p>You can add a class to your app element container like &quot;not-ready&quot;. Then in your css display that .not-ready with a loading animation. Once you have initialized everything you can remove the &quot;not-ready&quot; class name.</p>

<p>You can change the DOM99 syntax. To do that follow the instructions in js/dom99ConfigurationExample.js</p>
</article>

<article  id="discussion">
<h2>Discussion</h2>

<h4>Chat</h4>

<p><a href="https://dystroy.org/miaou/3">Chat (need a Github account)</a></p>

<h4>Issues reports</h4>

<p><a href="https://github.com/GrosSacASac/DOM99/issues">Issues report</a></p>

<h4>Contributing</h4>

<ul><li><a href="contributing.md">Contributing</a></li><li><a href="openquestions.md">Open questions</a></li></ul>
</article>

<article id="license">
<h2>License</h2>

<p><a href="https://opensource.org/licenses/MIT">MIT LICENSE</a></p>

</article>
<article id="performance">
<h2>Performance</h2>

<h3>General Tips</h3>

<p>In short: Rendering and painting the DOM is slow, JavaScript itself is fast. Simply changing a class name of an element can cause the browser to do heavy computation under the hood. For very simple programs, performance may not be an issue at all.</p>

<ul><li>Avoid Document Object Model (DOM) Access in big loops</li><li>Instead compute the result in your loop first, then assign the final result to the DOM</li><li>Avoid read/write alternations with the DOM</li><li>Instead chain reads, then chain writes </li><li>Use callbacks or Promises or equivalent for future events (example XMLHttpRequest), never block !</li><li>If you have more performance issues, profile first to know what is the cause</li><li>If you need to do heavy computation, consider using Web Workers</li><li><a href="https://docs.webplatform.org/wiki/tutorials/speed_best_practices">More tips</a></li><li><a href="http://www.html5rocks.com/en/features/performance">Even more tips</a></li></ul>

<h3>How is DOM99 fast ?</h3>

<ul><li>Load time element selection and binding instead of runtime element selection and binding </li><li>The abstraction layer is small, no assumptions are made</li><li>No complexity, no dirty checking, no separate model under the hood</li></ul>
</article>

<article id="security">
<h2>Security</h2>

<h3>General tips</h3>

<ul><li>Don&#39;t BlackList, Aggressively White-list</li><li>Don&#39;t mix data with code, use parameter injection with proper escaping and encoding</li><li>Don&#39;t trust what you don&#39;t control, validate size and format instead</li><li>Every software component should be so simple that it is obviously safe</li><li>Avoid complexity</li><li>Aggressively block if some behaviours are undefined</li><li>Talk with security experts</li></ul>

<h3>DOM99 and security</h3>

<p>DOM99 itself is secure. It does nothing by itself really. It is only a framework to organize your view. <code>D.vr</code> uses textContent or value by default. </p>

<p>If you apply the general tips above you know that you have to check if the clients browser have all features you need to run your software before running it. You also validate input on the server etc, etc. There are tons of blogs about security out there.</p>
</article>

<article id="history">
<h2>History</h2>

<p>The first version of DOM99 was rapidly prototyped by Cyril Walle (GrosSacASac) in late 2015 for JavaScript teaching purposes to people with a designer background. It was easy to let them play with their first JavaScript functions and see result on the web page just by assigning the result in a JS variable. It took away all the headaches about DOM manipulation. It was written in ES2015 code and transpiled to ES5.</p>

<p>In march 2016 I decided to share DOM99 after heavy code changes on Github and NPM in its own repository instead of some sub-folder in some other project.</p>
</article>

<article id="future">
<h2>Future</h2>

<h3>What is coming soon:</h3>

<ul><li>System improvements</li><li>Better documentation</li><li>Custom Element Life cycle declaration</li><li>Waiting for custom-element spec to finalize to update DOM99</li></ul>

<h3>Abstract directions for the future or Specification</h3>

<ul><li>Freedom</li><li>Simplicity in system and usage</li><li>Encourage declarative UI programming models</li><li>Focus on the view</li><li>Built on top of web standards</li><li>Not bloatware</li></ul>

<p>This leaves more freedom to combine DOM99 with the other needs. I encourage you to use simplified APIs for client-server communication alongside DOM99 and anything else that is complementary to accelerate the development process.</p>
</article>
</div>
<script src="../polyfill.min.js"></script>
<script src="../js/dom99.es5.min.js"></script>
<!-- Usually inline scripts are bad, but here we use them to display the source of the script with .textContent as well as executing it. Without need to use extra XHRs Also not indented first for pre tags -->

<!-- Hello World -->
<template data-el="Hello WorldHtml">
<span data-vr="first"></span>
<span data-vr="last"></span>
</template>

<script data-el="Hello WorldJs">
dom99.vr.first = "Hello";
dom99.vr.last = "World";
</script>

<!-- Hello World 2-->
<template data-el="Hello World 2Html">
<input data-vr="text"><br>
<span data-vr="text"></span>
</template>

<script data-el="Hello World 2Js">
dom99.vr.text = "Hello DOM99";
</script>

<!-- Multiplier-->
<template data-el="MultiplierHtml">
<input data-vr="a" data-fx="change-calculate" type="range" min="-1.0" max="25.0" step="1.0">
<span> X </span>
<input data-vr="b" data-fx="change-calculate" type="range" min="-1.0" max="25.0" step="1.0">
<span data-vr="a"></span> X <span data-vr="b"></span><span> = </span><output data-vr="result"></output>
</template>
<script data-el="MultiplierJs">
"use strict";
//Use a shorter name
var D = dom99;

D.fx.calculate = function (event) {
    //.vr variables are Strings by default
    D.vr.result = Number(D.vr.a) * Number(D.vr.b);
};

D.vr.a = 7;
D.vr.b = 6;
//invoke event handler to compute the first result
D.fx.calculate();
</script>


<!-- Lists -->
<template data-el="ListsHtml">
<ul data-vr="fruits-li">
</ul>
</template>
<script data-el="ListsJs">
/*const D = dom99;*/
D.vr.fruits = ["apple", "kiwi", "banana", "orange"];
</script>

<script src="js/documentation.es5.min.js"></script>
</body>
</html>